# 2.5.1~2.5.3

## HTTP/1.0

서버와 호스트가 하나임을 가정한다.

한 연결 당 하나의 요청만을 처리한다. → 서버로부터 파일(.html, .js, .css)을 가져올 때마다 TCP 3-웨이 핸드셰이크를 반복해야 한다. → RTT가 증가한다. → 서버에 부담이 가중되고, 사용자측 응답 시간은 길어진다.

<aside>
💡 **RTT**

Round-Trip Time

패킷이 목적지에 도달한 후 출발지로 다시 돌아오기까지 걸리는 패킷 왕복 시간

ping과 동일한 개념으로 사용된다.

</aside>

<aside>
💡 **RTT의 증가 해결 방법**

1. **이미지 스플리팅**
    
    웹 페이지를 불러올 때 모든 이미지를 한 번에 다운로드하게 되면 RTT가 증가하여 페이지 로딩 시간이 길어질 수 있다. 
    
    이미지 스플리팅은 웹 페이지의 이미지를 여러 개의 작은 조각으로 나누어 서버에서 클라이언트로 전송하는 방법이다.
    
    1. 먼저, 전송할 이미지를 작은 조각들로 나눈다. 이때 조각의 크기는 전송 시간과 사용자 경험을 고려하여 결정된다.
    2. 나누어진 이미지 조각들을 동시에 전송한다. 이를 통해 여러 개의 작은 요청을 병렬로 처리하므로 전체 페이지의 로딩 시간이 단축된다.
    3. 사용자가 페이지를 스크롤할 때나 필요한 이미지가 보이는 시점에 해당 이미지의 조각이 다운로드된다. 
    
    이를 통해 초기 로딩 시간을 단축하고 사용자가 페이지를 더 빠르게 탐색할 수 있다.
    
2. **코드 압축**
    
    ![Untitled](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled.png)
    
    위 코드를 압축하면
    
    ![Untitled](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled%201.png)
    
    위와 같이 된다. → 개행 문자, 빈칸 등을 없애서 코드 크기 최적화 → 코드 용량 감소
    
3. **이미지 Base64 인코딩**
    
    이미지를 64 진법으로 이루어진 문자열로 인코딩 → 서버에게 이미지에 대한 HTTP 요청이 이루어지지 않음: 요청 횟수 자체를 줄이는 것 → 이 문자열은 웹 페이지나 앱과 함께 HTML, CSS 또는 JavaScript와 같은 텍스트 기반 파일에 직접 포함되어 전송됨 → html 파일 자체의 크기가 커짐. 즉, Base64 인코딩을 하면 오히려 문자열의 크기가 약 37% 커진다. ⇒ 따라서, 작은 이미지나 아이콘과 같은 경우에 유용하다. 
    
    이 방법을 사용할 때는 이미지의 크기와 종류를 신중하게 고려해야 한다.
    
4. **HTTP/1.1 이후 버전 사용**
</aside>

<aside>
💡 **인코딩**

인코딩이란 형태나 형식을 다른 형태나 형식으로 변환하는 것이다.

이를 통해 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등의 목적을 이룰 수 있다.

</aside>

## HTTP/1.1

매번 TCP 연결을 하는 것이 아닌, 한 번 TCP 초기화가 이루어지면 keep-alive 옵션을 통해 계속 송수신이 이루어지게 하는 프로토콜이다.

단, 단점이 세 가지 있다. 

1. **병렬요청은 불가능하다.** 
병렬요청을 하려면 다중 TCP 연결을 해야함 → 이럴 바엔, HTTP/2를 써라.

![면접을 위한 CS 전공 지식 노트](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled%202.png)

면접을 위한 CS 전공 지식 노트

→ HTTP/2의 멀티플렉싱 기술로 해결됨

또한, 

1. **HOL(Head Of Line Blocking) 문제가 있다.**

<aside>
💡 **HOL(Head Of Line Blocking)**

같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상

![면접을 위한 CS 전공 지식 노트](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled%203.png)

면접을 위한 CS 전공 지식 노트

</aside>

즉, 내가 선 줄(line)에서 내 앞의 패킷(Head)이 육중해서 오래 걸려(Blocking)도, 얘가 먼저 처리되어야 한다. → 큐라서 그러하다.

![Untitled](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled%204.png)

→ HTTP/2의 멀티플렉싱 기술로 해결됨

1. **무거운 헤더**

HTTP/1.1은 헤더에 많은 정보(쿠키 등의 메타데이터)가 들어가 있다.

⇒ HTTP/2의 헤더 압축 기술로 해결됨

## HTTP/2

HTTP/1.1의 문제를 해결하는 프로토콜

즉, HTTP/1.x보다 지연 시간은 줄어들고, 응답 시간은 더 빠르며, 멀티플렉싱, 헤더 압축, 서버 푸시 기술, 요청의 우선순위 처리 등의 기술이 적용되어 있다.

HTTP 1.0: 일반 텍스트 메시지를 전송, 줄바꿈으로 데이터를 구분

HTTP 2.0: 바이너리 데이터를 전송, 메시지가 프레임으로 캡슐화되어 전송됨

![Untitled](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled%205.png)

HTTP/2는 멀티플렉싱(multiplexing)을 하기 위해, 바이너리 프레이밍 계층이 새로 들어간다. → HOL을 해결한다. 

### 멀티플렉싱(multiplexing)

여러 개의 스트림을 통해 송수신한다.

특정 스트림의 패킷이 손실되었더라도 해당 스트림만 영향을 받고 나머지 스트림은 정상적으로 송수신된다. → 즉, 스트림 내의 데이터들이 쪼개어져 송신되고, 이를 받는 수신 측에서는 쪼개진 데이터들을 조립하여 수신한다. ⇒ 단일 연결 만으로도, [HTTP/1.x에선 처리 할 수 없던 병렬 요청](https://www.notion.so/Network-ffadd5fc3622419bb705334183e3dcbe?pvs=21)을 처리할 수 있음 ⇒ [HTTP/1.x의 HOL blocking 문제](https://www.notion.so/Network-ffadd5fc3622419bb705334183e3dcbe?pvs=21) 해결됨

<aside>
💡 **스트림**

시간에 따라 쌓이는 일련의 데이터 요소를 가리키는 데이터의 흐름

</aside>

근데 쪼개면, 순서가 뒤엉킬텐데? → 헤더에 stream ID로 쪼개어진 그 순서를 맞춘다. → 하지만, TCP 초기 연결 시간 조차도 아깝다면? ⇒ HTTP/3로 해결

### 헤더 압축

HTTP/1.x가 가진 또 다른 문제는 큰 헤더다.

이를 위해 허프만 코딩 압축 기술 알고리즘이 쓰이는 HPACK 압축 형식을 사용한다.

<aside>
💡 **허프만 코딩(huffman coding)**

문자열을 문자 단위로 쪼개고, 문자들의 빈도수를 센 다음, 빈도가 높은 정보는 짧은 비트 시퀀스를 할당하여 표현하고 빈도가 낮은 정보는 긴 비트 시퀀스를 할당한다. → 전체 데이터 표현에 필요한 비트량을 줄인다.

예를 들어, "HELLO"라는 문자열이 있을 때, 이 문자열은 'H', 'E', 'L', 'O'로 구성되어 있다. 허프만 코딩 알고리즘은 각 문자의 빈도를 조사하여 이에 대응하는 이진 코드를 생성한다. 빈도수는 다음과 같다.

- 'H' : 1회
- 'E' : 1회
- 'L' : 2회
- 'O' : 1회

이 정보를 기반으로 허프만 코딩은 다음과 같은 이진 코드를 할당할 수 있다. 

- 'H' : 00
- 'E' : 01
- 'L' : 10
- 'O' : 11

즉, "HELLO"라는 문자열은 "00011011"로 압축된다.

</aside>

### 서버 푸쉬

HTTP/1.x에선 클라이언트가 서버에 요청해야 파일을 다운로드 할 수 있다.

HTTP/2부터는 클라이언트의 요청이 없어도 서버가 관련 리소스를 알아서 푸쉬한다.

![Untitled](2%205%201~2%205%203%209cc2f60a921348708fcbb90697d392e6/Untitled%206.png)

그리고, 이렇게 푸쉬하여 보내는 리소스도 우선순위에 따라 보낸다.

⇒ HTTP/2는 한마디로 서버가 하드캐리하는 방식임